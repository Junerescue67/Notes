## 类的大小计算
类的大小是指类的实例化对象的大小，用 sizeof 对类型名操作时，结果是该类型的对象的大小。
计算原则：<br>
<ul>
<li>遵循结构体的对齐原则。</li>
<li>与普通成员变量有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。因为静态数据成员被类的对象共享，并不属于哪个具体的对象。</li>
<li>虚函数对类的大小有影响，是因为虚函数表指针的影响。</li>
<li>虚继承对类的大小有影响，是因为虚基表指针带来的影响。</li>
<li>空类的大小是一个特殊情况，空类的大小为 1，当用 new 来创建一个空类的对象时，为了保证不同对象的地址不同，空类也占用存储空间。</li>
</ul>

## 内存泄露
由于疏忽或错误导致的程序未能释放已经不再使用的内存。

## 怎么防止内存泄露？内存泄露检测工具的原理？
<ul>
<li>内部封装：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。
<li>智能指针
</ul>

## 检测原理：
<ul>
<li>当要读写内存中某个字节时，首先检查这个字节对应的 Valid-Address 表中对应的 bit。如果该 bit 显示该位置是无效位置，Memcheck 则报告读写错误。
<li>内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节在 Valid-Value 表对应的 bits 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 Memcheck 会检查 Valid-Value 表对应的 bits，如果该值尚未初始化，则会报告使用未初始化内存错误。</ul>

## 虚函数
### 虚函数和纯虚函数的区别
<ul>
<li>虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用</li>
<li>纯虚函数定义除了要加<strong>virtual</strong>关键字，还要加<strong>=0</strong>
</ul>

### 禁止构造函数调用
=delete<br>

## 构造函数、析构函数是否需要定义成虚函数？为什么？

构造函数一般不定义为虚函数，原因：
<ul>
<li>从存储空间的角度考虑：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。
从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的。
<li>从实现上考虑：虚函数表是在创建对象之后才有的，因此不能定义成虚函数。
<li>从类型上考虑：在创建对象时需要明确其类型。</ul>

<ol>
析构函数一般定义成虚函数，原因：
析构函数定义成虚函数是为了防止内存泄漏，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。
</ol>

## 如何避免拷贝
<ul>
<li>=delete
<li>声明一个基类，具体做法如下。
<ul>
<li>定义一个基类，将其中的拷贝构造函数和赋值构造函数声明为私有 private
<li>派生类以私有 private 的方式继承基类</ul></ul>

## 多重继承带来的问题
命名冲突和数据冗余<br>
解决办法:**虚继承**

## 拷贝构造函数必须为引用
>防止无限递归

## C++ 类对象的初始化顺序
基类构造函数–>派生类成员变量的构造函数–>自身构造函数<br>

## 为什么用成员初始化列表会快一些？
>因为类类型的数据成员对象在进入函数体前已经构造完成，也就是说在成员初始化列表处进行构造对象的工作，调用构造函数，在进入函数体之后，进行的是对已经构造好的类对象的赋值，又调用个拷贝赋值操作符才能完成（如果并未提供，则使用编译器提供的默认按成员赋值行为）<br>

## 浅拷贝和深拷贝
>浅拷贝只拷贝栈中地址，实际指向原来对象<br>
深拷贝不仅拷贝栈中数据，还拷贝堆中数据，和原来是两个对象

## std::move

```CPP
template <typename T>
typename remove_reference<T>::type&& move(T&& t){<br>
    return static_cast<typename remove_reference<T>::type &&>(t);<br>
}
```
### std::move() 实现原理：
<ol>
<li>利用引用折叠原理将右值经过 T&& 传递类型保持不变还是右值，而左值经过 T&& 变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变；
<li>然后通过 remove_refrence 移除引用，得到具体的类型 T；
<li>最后通过 static_cast<> 进行强制类型转换，返回 T&& 右值引用。</ol>

## nullptr 的优势：
<ul>
<li>有类型，类型是 typdef decltype(nullptr) nullptr_t;，使用 nullptr 提高代码的健壮性。
<li>函数重载：因为 NULL 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 NULL，可能会出现，不知和哪一个函数匹配的情况；但是传递实参 nullptr 就不会出现这种情况。</ul>

## 强制类型转换有哪几种？
<ul>
<li>static_cast：用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。

用于基本数据类型的转换。
用于类层次之间的基类和派生类之间 指针或者引用 的转换（不要求必须包含虚函数，但必须是有相互联系的类），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用 dynamic_cast 进行下行转换。
可以将空指针转化成目标类型的空指针。
可以将任何类型的表达式转化成 void 类型。
<li>const_cast：强制去掉常量属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。

<li>reinterpret_cast：改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。

<li>dynamic_cast：

其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查。
只能用于带有虚函数的基类或派生类的指针或者引用对象的转换，转换成功返回指向类型的指针或引用，转换失败返回 NULL；不能用于基本数据类型的转换。
在向上进行转换时，即派生类类的指针转换成基类类的指针和 static_cast 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）。
</ul>

##函数模板和类模板的区别？
<ul>
<li>实例化方式不同：函数模板实例化由编译程序在处理函数调用时自动完成，类模板实例化需要在程序中显示指定。
<li>实例化的结果不同：函数模板实例化后是一个函数，类模板实例化后是一个类。
<li>默认参数：类模板在模板参数列表中可以有默认参数。
<li>特化：函数模板只能全特化；而类模板可以全特化，也可以偏特化。
<li>调用方式不同：函数模板可以隐式调用，也可以显示调用；类模板只能显示调用。
</ul>

## 设计模式有 6 大设计原则：
<ul>
<li>单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。
<li>开放封闭原则：软件实体可以扩展，但是不可修改。即面对需求，对程序的改动可以通过增加代码来完成，但是不能改动现有的代码。
<li>里氏代换原则：一个软件实体如果使用的是一个基类，那么一定适用于其派生类。即在软件中，把基类替换成派生类，程序的行为没有变化。
<li>依赖倒转原则：抽象不应该依赖细节，细节应该依赖抽象。即针对接口编程，不要对实现编程。
<li>迪米特原则：如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某个方法的话，可以通过第三个类转发这个调用。
<li>接口隔离原则：每个接口中不存在派生类用不到却必须实现的方法，如果不然，就要将接口拆分，使用多个隔离的接口。
</ul>

## 设计模式分为三类：
<ul>
<li>创造型模式：单例模式、工厂模式、建造者模式、原型模式
<li>结构型模式：适配器模式、桥接模式、外观模式、组合模式、装饰模式、享元模式、代理模式
<li>行为型模式：责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式
</ul>

## 下面介绍常见的几种设计模式：
<ul>
<li>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
<li>工厂模式：包括简单工厂模式、抽象工厂模式、工厂方法模式
<ul><li>简单工厂模式：主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的结果。
<li>工厂方法模式：修正了简单工厂模式中不遵守开放封闭原则。把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。
<li>抽象工厂模式：定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。</ul>
<li>观察者模式：定义了一种一对多的关系，让多个观察对象同时监听一个主题对象，主题对象发生变化时，会通知所有的观察者，使他们能够更新自己。
<li>装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成派生类更为灵活。</ul>

<ol>

### 单例模式：保证类的实例化对象仅有一个，并且提供一个访问他的全局访问点。

### 应用场景：
<ul>
<li>表示文件系统的类，一个操作系统一定是只有一个文件系统，因此文件系统的类的实例有且仅有一个。
<li>打印机打印程序的实例，一台计算机可以连接好几台打印机，但是计算机上的打印程序只有一个，就可以通过单例模式来避免两个打印作业同时输出到打印机。
</ul>

### 实现方式：
单例模式可以通过全局或者静态变量的形式实现，这样比较简单，但是这样会影响封装性，难以保证别的代码不会对全局变量造成影响。
<ul>
<li>默认的构造函数、拷贝构造函数、赋值构造函数声明为私有的，这样禁止在类的外部创建该对象；
<li>全局访问点也要定义成 静态类型的成员函数，没有参数，返回该类的指针类型。因为使用实例化对象的时候是通过类直接调用该函数，并不是先创建一个该类的对象，通过对象调用。</ul>


## 不安全的实现方式：
原因：考虑当两个线程同时调用 getinstance 方法，并且同时检测到 instance 是 NULL，两个线程会同时实例化对象，不符合单例模式的要求。
</ol>